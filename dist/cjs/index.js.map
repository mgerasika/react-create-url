{"version":3,"file":"index.js","sources":["../../src/lib.tsx"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninterface IDictionary<TValue = any> {\n  [id: string]: TValue;\n}\n\nexport interface IUrlItem {\n  toString: () => string;\n  formattedName?: string;\n}\n\nexport class UrlItem implements IUrlItem {\n  public name = \"\";\n  public formattedName = \"\";\n  public parent: UrlItem | undefined = undefined;\n  private _canFormatRouteName? = true;\n\n  toJSON(): string {\n    return this.toString();\n  }\n\n  constructor(\n    name: string,\n    parent?: UrlItem | undefined,\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    routes?: unknown,\n    canFormatRouteName?: boolean\n  ) {\n    this.name = name;\n    this.formattedName = canFormatRouteName ? formatUrlName(name) : name;\n\n    this.parent = parent;\n    this._canFormatRouteName = canFormatRouteName;\n    if (routes && typeof routes === \"object\") {\n      const keys = Object.keys(routes);\n      keys.forEach((key) => {\n        const value = (routes as any)[key];\n        const self = this as unknown as IDictionary;\n        if (typeof value === \"function\" && key.startsWith(\"external_\")) {\n          self[key] = (arg1: string, arg2: string, arg3: string): UrlItem => {\n            return value(arg1, arg2, arg3);\n          };\n        } else if (typeof value === \"function\") {\n          const subRoutes = value();\n          self[key] = (arg: string): UrlItem => {\n            //if argument not passed into function - then add ':' symbol before key.\n            return new UrlItem(arg || \":\" + key, this, subRoutes, false);\n          };\n        } else if (value instanceof UrlItem) {\n          self[key] = value.name;\n        } else {\n          self[key] = new UrlItem(key, this, value, true);\n        }\n      });\n    }\n  }\n\n  toString(): string {\n    const name = this._canFormatRouteName\n      ? formatUrlName(this.name)\n      : this.name;\n    return this.parent ? this.parent + \"/\" + name : name;\n  }\n}\n\nconst formatUrlName = (str: string): string => {\n  if (str === \"index\") {\n    return \"\";\n  }\n  return str.toString().replace(/([A-Z])/g, (str) => \"-\" + str.toLowerCase());\n};\n\nexport function createUrl<T>(routes: T): T {\n  return new UrlItem(\"\", undefined, routes, true) as unknown as T;\n}\n\nexport const EMPTY_URL_ITEM: IUrlItem = {} as unknown as IUrlItem;\n"],"names":["UrlItem","name","formattedName","parent","undefined","_canFormatRouteName","toJSON","this","toString","constructor","routes","canFormatRouteName","formatUrlName","Object","keys","forEach","key","value","self","startsWith","arg1","arg2","arg3","subRoutes","arg","str","replace","toLowerCase"],"mappings":"aAUO,MAAMA,EACJC,KAAO,GACPC,cAAgB,GAChBC,YAA8BC,EAC7BC,qBAAuB,EAE/BC,SACS,OAAAC,KAAKC,UACb,CAEDC,YACER,EACAE,EAEAO,EACAC,GAOA,GALKV,KAAAA,KAAOA,EACPC,KAAAA,cAAgBS,EAAqBC,EAAcX,GAAQA,EAE3DE,KAAAA,OAASA,EACTE,KAAAA,oBAAsBM,EACvBD,GAA4B,iBAAXA,EAAqB,CAC3BG,OAAOC,KAAKJ,GACpBK,SAASC,IACZ,MAAMC,EAASP,EAAeM,GACxBE,EAAOX,KACT,GAAiB,mBAAVU,GAAwBD,EAAIG,WAAW,aAChDD,EAAKF,GAAO,CAACI,EAAcC,EAAcC,IAChCL,EAAMG,EAAMC,EAAMC,QAEtB,GAAqB,mBAAVL,EAAsB,CAChCM,MAAAA,EAAYN,IAClBC,EAAKF,GAAQQ,GAEJ,IAAIxB,EAAQwB,GAAO,IAAMR,EAAKT,KAAMgB,GAAW,EAEzD,MACCL,EAAKF,GADIC,aAAiBjB,EACdiB,EAAMhB,KAEN,IAAID,EAAQgB,EAAKT,KAAMU,GAAO,EAC3C,GAEJ,CACF,CAEDT,WACE,MAAMP,EAAOM,KAAKF,oBACdO,EAAcL,KAAKN,MACnBM,KAAKN,KACF,OAAAM,KAAKJ,OAASI,KAAKJ,OAAS,IAAMF,EAAOA,CACjD,EAGH,MAAMW,EAAiBa,GACT,UAARA,EACK,GAEFA,EAAIjB,WAAWkB,QAAQ,YAAaD,GAAQ,IAAMA,EAAIE,uCAOvB,CAAA,sCAJjC,SAAsBjB,GACpB,OAAA,IAAIV,EAAQ,QAAII,EAAWM,GAAQ,EAC3C"}